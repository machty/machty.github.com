
<!DOCTYPE HTML>
<html>
<head>
	<script data-cfasync="false" type="text/javascript" src="//use.typekit.net/axj3cfp.js"></script>
	<script data-cfasync="false" type="text/javascript">try{Typekit.load();}catch(e){}</script>
	<meta charset="utf-8">
	<title>Ember.js, random thoughts, journal  | machty's thoughtz</title>

<meta name="author" content="Alex Matchneer"> 

<meta name="description" content="I'm on Ember core and contribute to lots of stuff prefixed with "Em"."> <meta name="keywords" content="">

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="machty's thoughtz" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<script type="text/javascript" src="/javascripts/jquery.fancybox.pack.js"></script>

<script language="Javascript" type="text/javascript">
$(document).ready(
  function() {
    (function($) {
      $(".fancybox[data-content-id]").each(function() {
        this.href = $(this).data('content-id');
      });
      $(".fancybox").fancybox({
        beforeLoad: function() {
          var el, 
              id = $(this.element).data('title-id');

          if (id) {
            el = $('#' + id);

            if (el.length) {
              this.title = el.html();
            }
          }
          if ($(this).data('content')) {
            this.content = $(this).data('content');
          }
        },
        helpers: {
          title: {
            type: 'inside'
          }
        }
      });
    })(jQuery);
  }
);
</script>

	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">machty's thoughtz</a></h1>
<h4>Ember.js, random thoughts, journal</h4>
<nav id="main-nav"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/archives">Archive</a></li>
	<li>
    <span>
    <a href="http://www.cram.com/flashcards/alexmatchneercom-4692833" target="_blank">Flashcards</a>
    </span>
    <span>
    (<a href="/blog/2014/04/12/blog-flashcards/">explanation</a>)
    </span>
  </li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul>
	<li><a href="/">Blog</a></li>
	<li><a href="/archives">Archive</a></li>
	<li>
    <span>
    <a href="http://www.cram.com/flashcards/alexmatchneercom-4692833" target="_blank">Flashcards</a>
    </span>
    <span>
    (<a href="/blog/2014/04/12/blog-flashcards/">explanation</a>)
    </span>
  </li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:machty.github.com">
			</form>
		</div>
	</div>
</nav>


</header>

	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/03/25/shiggity-wat/">
		
			Shiggity Wat</a>
	</h2>
	<div class="entry-content">
		<h2>IP Spoofing</h2>

<p>What&#8217;s to stop you from sending out packets with someone else&#8217;s IP as
the source?</p>

<p>http://en.wikipedia.org/wiki/IP_address_spoofing</p>

<ul>
<li>packet filtering

<ul>
<li>ingress: gateway blocks incoming packets with source IP that can
only belong to someone inside of the network</li>
<li>egress: gateway blocking outgoing packets with source IP from
outside of the network (altruistic since it prevents hackers from
hacking folk outside of the network)</li>
</ul>
</li>
<li>upper layer protocol

<ul>
<li>TCP prevents IP spoofing by use of sequence numbers; an attacker
would have to guess at a correct sequence number in order for it to
be considered valid</li>
</ul>
</li>
</ul>


<h2>RxJS</h2>

<h3>generate</h3>

<pre><code>var source = Rx.Observable.generate(
    0,
    function (x) { return x &lt; 3; }, // terminate condition
    function (x) { return x + 1; }, // step fn
    function (x) { return x*2; }    // map fn for values emitted...?
);
</code></pre>

<p>The last fn is weird&#8230; seems like the above is the equivalent of:</p>

<pre><code>var source = Rx.Observable.generate(
    0,
    function (x) { return x &lt; 3; }, 
    function (x) { return x + 1; },
    function (x) { return x; }    
).map(x =&gt; x*2);
</code></pre>

<p>So why embed the <code>map</code> operator? or as they call it the select.</p>

<pre><code>Rx.Observable.prototype.map === Rx.Observable.prototype.select // true
</code></pre>

<h3>generateWith relative/absolute time</h3>

<p>Like <code>generate</code> but adds a time selector fn: for each value you can
decide when it should fire. So you could feasible reverse the firing
time of a series of events, e.g. 1,2,3,4,5 fires in the reverse order:</p>

<pre><code>var source = Rx.Observable.generateWithRelativeTime(
    1,
    function (x) { return x &lt; 4; },
    function (x) { return x + 1; },
    function (x) { return x; },
    function (x) { return 100 * (5-x); }
);

"Next: 1"
"Next: 2"
"Next: 3"
"Completed"
</code></pre>

<p>NOPE I was wrong; the time selector generates the time <em>between</em> events,
not the time relative to the start of observation. I&#8217;m guessing that can
be accomplished via the absolute form:</p>

<pre><code>var now = Date.now();
var source = Rx.Observable.generateWithAbsoluteTime(
    1,
    function (x) { return x &lt; 4; },
    function (x) { return x + 1; },
    function (x) { return x; },
    function (x) { return now + 100 * (5-x); }
).timeInterval();

"Next: 1:402"
"Next: 2:6"
"Next: 3:2"
"Completed"
</code></pre>

<p>WRONG AGAIN! Order is preserved, with the already-elapsed events firing
immediately once the first one fires.</p>

<h3>generate as for loops:</h3>

<p>Instead of</p>

<pre><code>for (var x = 0; x &lt; 10; ++x) {
  console.log(x*2);
}
</code></pre>

<p>you do</p>

<pre><code>var source = Rx.Observable.generate(
    0,
    function (x) { return x &lt; 10; }, 
    function (x) { return x + 1; },  // ++x
    function (x) { return x*2; }  
);

// or source.subscribe
source.forEach((val) =&gt; {
  console.log(val);
});
</code></pre>

<p>Keep in mind that</p>

<pre><code>Rx.Observable.prototype.forEach === Rx.Observable.prototype.subscribe
</code></pre>

<p>They&#8217;re aliases of each other, they both:</p>

<ul>
<li>activate an observable</li>
<li>are intended to cause some sort of side effects</li>
</ul>


<p>Why write in observable form?</p>

<ul>
<li>composability</li>
<li>much harder to troll yourself w &#8220;global&#8221; mutable vars used for iteration</li>
<li>you&#8217;re writing in a way that can effortlessly handle the dimension of time</li>
</ul>


<h2>Subscriber stack</h2>

<p>How would you get more explicit bubbling behavior that we&#8217;re familiar
with from bubbling actions in Ember?</p>

<p>Basically I want there to be some root subject/observable on a parent
route, and then child routes can push their subscription onto that
observable&#8217;s stack of subscriptions, and only the subscription at the
top of the stack.</p>

<p>This doesn&#8217;t accomplish bubbling per se; it&#8217;s a non-bubbling form of
first-responder. Do we want bubbling?</p>

<p>Actually yeah I think we want bubbling; what we don&#8217;t want is routes
accidentally getting actions invoked on them because at some point later
in the game a child route invokes an action (just string names) and it
accidentally leaks out, causing havoc on parent routes, etc.</p>

<p>But to be able to pass on the action is probably nice.</p>

<pre><code>// within child route
someParentRoute.observableStack.subscribe((e) =&gt; {
  if (canHandle(e.value)) {
    // do stuff
  } else {
    e.bubble();
  }
});
</code></pre>

<p>and this subscription would be <code>dispose</code>d upon route deactivation so it
cleans itself up.</p>

<p>The problem with this is once you start needing to apply operators, you
need some way of signalling the bubble later on?</p>

<pre><code>someParentRoute.observableStack
               .delay(1000)
               .map((e) =&gt; someCopyThatStillPreservesBubbleFn})
               .subscribe((e) =&gt; {
                 if (canHandle(e.value)) {
                   // do stuff
                 } else {
                   e.bubble();
                 }
               });
</code></pre>

<h2>Alex versus invalidation</h2>

<p>https://github.com/ef4/liquid-fire/issues/222</p>

<h2>iOS 7 and 8 usage</h2>

<p>As of 3/29/2015:</p>

<ul>
<li>iOS 8: 77%</li>
<li>iOS 7: 20%</li>
<li>Earlier: 3%</li>
</ul>


<h2>WKWebView</h2>

<p>Only in iOS 8, comes with Nitro engine and bunch of other things.</p>

<p>http://nshipster.com/wkwebkit/</p>

<ul>
<li>https://github.com/Telerik-Verified-Plugins/WKWebView

<ul>
<li>probably the best stab at a working plugin</li>
<li>there are many issues (i would not use it at this point)</li>
<li>spins up an embedded server in order to:

<ul>
<li>bypass CORS</li>
<li>allow querying file:// protocol</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>It&#8217;s also only iOS8+; the plugin is smart enough to fall back to
UIWebView, but then you&#8217;ve just bumped an exponent on complexity, more
shit to test.</p>

<p>There is also Ludei Cocoonjs. But Iiiii couldn&#8217;t get it to work. :)</p>

<h2>Rx: switch</h2>

<p>When you already have an Observable of Observables, you can call
<code>.switch()</code> to produce an Observable that only emits values from the
most recent observable :) isn&#8217;t terminology fun.</p>

<p>So this:</p>

<pre><code>obs.map((val) =&gt; someObservableBasedOnVal)
   .switch();
</code></pre>

<p>is the same as</p>

<pre><code>obs.flatMapLatest((val) =&gt; someObservableBasedOnVal);
</code></pre>

<h2>Multiple cursors, DevTools and Vim</h2>

<p>Command click: multiple cursors</p>

<p>Cmd+D selects the next instance (effectively adding a multiple cursor).
Really a cursor is a selection with zero chars selected.</p>

<p>Just downloaded https://github.com/terryma/vim-multiple-cursors</p>

<p>Ctrl-n: select next occurrence of hovered word</p>

<p>Ctrl-p: undo most recent selection</p>

<p>Ctrl-x: skip current selection</p>

<p>MultipleCursorsFind: optionally select range in v mode, then type a
regex to select them shits as multiple cursors.</p>

<p>NOTE: in visual mode, <code>o</code> swaps the cursor to the other side to let you
modify the selection from the other end.</p>

<h2>Why flatMapLatest always trips me up</h2>

<p>http://jsbin.com/nupafu/1/edit?html,js,console</p>

<pre><code>console.clear();

Rx.Observable.just(1)
  .takeUntil(Rx.Observable.timer(10))
  .doOnCompleted(() =&gt; console.log("doOnCompleted"))
  .flatMapLatest(() =&gt; {
    return Rx.Observable.timer(500);
  })
  .subscribe(() =&gt; {
    console.log("EVENT");
  }, null,
  () =&gt; {
    console.log("COMPLETE");
  });
</code></pre>

<p>Output:</p>

<pre><code>"doOnCompleted"
"EVENT"
"COMPLETE"
</code></pre>

<p>This sequence might seem obvious here but I ALWAYS make the mistake of
thinking that because there&#8217;s a takeUntil on the source observable,
that&#8217;ll somehow cause all subscribing observables to immediately
complete. NOPE. If that were the case, then promise chains wouldn&#8217;t work
since they&#8217;re just single value observables that complete after their
first value, and if completion force completed any subscribers then you
couldn&#8217;t have async chains of logic. Anyway.</p>

<p>So I guess that means you really need to gate at every potential side
effect via takeUntil? e.g.</p>

<p>http://jsbin.com/nupafu/1/edit?html,js,console</p>

<pre><code>Rx.Observable.interval(200)
  .takeUntil(Rx.Observable.timer(250))
  .do(() =&gt; console.log("start"))
  .flatMapLatest(() =&gt; { return Rx.Observable.timer(500); })
  .do(() =&gt; console.log("one"))
  .flatMapLatest(() =&gt; { return Rx.Observable.timer(500); })
  .do(() =&gt; console.log("two"))
  .flatMapLatest(() =&gt; { return Rx.Observable.timer(500); })
  .do(() =&gt; console.log("three"))
  .subscribe(() =&gt; {
    console.log("EVENT");
  }, null,
  () =&gt; {
    console.log("COMPLETE");
  });
</code></pre>

<p>Output:</p>

<pre><code>"start"
"one"
"two"
"three"
"EVENT"
"COMPLETE"
</code></pre>

<p>I guess I could dispose the sub, but then no onCompletes get fired
(and it&#8217;s also just bad style).</p>

<pre><code>console.clear();

var sub = Rx.Observable.interval(200)
  .takeUntil(Rx.Observable.timer(250))
  .do(() =&gt; console.log("start"))
  .flatMapLatest(() =&gt; { return Rx.Observable.timer(500); })
  .do(() =&gt; console.log("one"))
  .flatMapLatest(() =&gt; { return Rx.Observable.timer(500); })
  .do(() =&gt; console.log("two"))
  .flatMapLatest(() =&gt; { return Rx.Observable.timer(500); })
  .do(() =&gt; console.log("three"))
  .subscribe(() =&gt; {
    console.log("EVENT");
  }, null,
  () =&gt; {
    console.log("COMPLETE");
  });

setTimeout(() =&gt; {
  sub.dispose();
}, 250);
</code></pre>

<p>Output:</p>

<pre><code>"start"
</code></pre>

<p>WHOA if I do onCompleted, then it skips all the shit in the middle
and still runs the completion handler!</p>

<p>http://jsbin.com/nupafu/4/edit</p>

<pre><code>console.clear();

var sub = Rx.Observable.interval(200)
  .takeUntil(Rx.Observable.timer(250))
  .do(() =&gt; console.log("start"))
  .flatMapLatest(() =&gt; { return Rx.Observable.timer(500); })
  .do(() =&gt; console.log("one"))
  .flatMapLatest(() =&gt; { return Rx.Observable.timer(500); })
  .do(() =&gt; console.log("two"))
  .flatMapLatest(() =&gt; { return Rx.Observable.timer(500); })
  .do(() =&gt; console.log("three"))
  .subscribe(() =&gt; {
    console.log("EVENT");
  }, null,
  () =&gt; {
    console.log("COMPLETE");
  });

setTimeout(() =&gt; {
  sub.onCompleted();
}, 250);
</code></pre>

<p>Output:</p>

<pre><code>"start"
"COMPLETE"
</code></pre>

<p>Question: is there a way to construct your observables, without
resorting to chaining takeUntil&#8217;s before every side-effect, such that
some onComplete along the way skips everyone else&#8217;s?</p>

<p>http://jsbin.com/nupafu/6/edit</p>

<pre><code>console.clear();
var o = Rx.Observable.interval(200)
  .do(() =&gt; console.log("start"))
  .flatMapLatest(() =&gt; { return Rx.Observable.timer(500); })
  .do(() =&gt; console.log("one"))
  .flatMapLatest(() =&gt; { return Rx.Observable.timer(500); })
  .do(() =&gt; console.log("two"))
  .flatMapLatest(() =&gt; { return Rx.Observable.timer(500); })
  .do(() =&gt; console.log("three"));

o.merge(Rx.Observable.timer(250).map(false))
  .subscribe(function(v) {
    console.log("EVENT " + v);
    if (v === false) {
      this.onCompleted();
    }
  }, null,
  () =&gt; {
    console.log("COMPLETE");
  });

"start"
"EVENT false"
"COMPLETE"
"start"
"start"
"start"
"start"
"start"
"start"
"start"
"start"
"start"
...
</code></pre>

<p>Why? Does <code>this.onCompleted()</code> not kill the current subscription?</p>

<p>This works:</p>

<pre><code>var sub = o.merge(Rx.Observable.timer(250).map(false))
  .subscribe(function(v) {
    if (v === false) {
      sub.onCompleted();
    }
  }, null,
  () =&gt; {
    console.log("COMPLETE");
  });
</code></pre>

<p>Apparently sub !== this. sub is an auto-detach observer, this is an
anonymous observer. Some rxjs internals I don&#8217;t wanna go into right now.</p>

<p>Maybe there&#8217;s a merge first operator that&#8217;ll work here.</p>

<p>https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/amb.md</p>

<p><code>amb</code> is close, but once a value is produced from the flatMapChain, then
the terminating observable is ignored. I want something that stops on
the first completed thing.</p>

<p>Note that <code>amb</code> has <a href="http://www.randomhacks.net/2005/10/11/amb-operator/">roots in Lisp</a>.
The base functionality in RxJS I guess can be used to approximate
something like</p>

<p>Oh man, I might be a HUGE idiot&#8230; I JUST NEED TO FUCKING PUT THE
TAKEUNTIL AT THE END OMG</p>

<h2>I&#8217;m waiting</h2>

<p>http://i.imgur.com/4ETXzun.webm</p>

<h2>Observable.using</h2>

<p>Resource/disposable + observable = using</p>

<pre><code>Rx.Observable.
  using(
    function () { return openFile('temp.txt', 'w+'); },
    function (fd) {
      return Rx.Observable.range(0, 10000)
        .map(function (v) { return Buffer(v); })
        .flatMap(function (buffer) {
          return appendAsync(fd, buffer);
        });
    }
  )
  .subscribe();
</code></pre>

<p><code>using</code> makes it clear what the resource/disposable. Otherwise you might
mix the two awkwardly in the body of the fn passed to
<code>Observable.create</code>.</p>

<h2>Rx grammar</h2>

<p>Observable sequences have the following grammar:</p>

<pre><code>onNext* (onCompleted|onError)?
</code></pre>

<p>0 or more <code>onNext</code>s followed by an optional <code>onCompleted</code> OR <code>onError</code>.
Infinite sequences or disposed sequences might never see <code>onCompleted</code>
or <code>onError</code>.</p>

<h2>Observable.defer vs Observable.create</h2>

<p>Defer wraps another underlying observable in a factory function and
guarantees that each subscription to the outer observable gets a fresh
subscription to a totally newly-generated inner observable&#8230; but how is
this different from cold observables in general?</p>

<p>Well before I say that, lemme just say <code>defer</code> is a useful pattern for
when you want to kick off a sequence but don&#8217;t really know which
observable to start with; a lame attempt to do this is via</p>

<pre><code>Rx.Observable.just()
  .flatMap(() =&gt; {
    if (wat) {
      return oneObservable;
    } else {
      return anotherObservable;
    }
  })
</code></pre>

<p>This could more clearly be written as</p>

<pre><code>Rx.Observable.defer(() =&gt; {
  if (wat) {
    return oneObservable;
  } else {
    return anotherObservable;
  }
});
</code></pre>

<p>But hey, observables are cold&#8230; how is this different than writing</p>

<pre><code>var obs = wat ? oneObservable : anotherObservable;
return obs; // someone will subscribe to it
</code></pre>

<p>The difference is the decision as to which observable to use is set once
and for all for all future subscribers. HORRIBLE ENGRISH MR MATCHNEER.
In other words: either all subscribers get oneObservable or they get
anotherObservable. If you wanted to <em>defer</em> that decision until each
subscription, that&#8217;s when you use defer.</p>

<p>So why not just use a factory function without using <code>defer</code>, e.g.</p>

<pre><code>function getObservable() {
  var obs = wat ? oneObservable : anotherObservable;
}

// then anyone who wants to subscribe:
getObservable().subscribe();
getObservable().subscribe();
getObservable().subscribe();
</code></pre>

<p>These all get fresh observables. But then if you did</p>

<pre><code>var obs = getObservable();
obs.subscribe();
obs.subscribe();
obs.subscribe();
</code></pre>

<p>then these would all get the same observable decided by the single  call
to getObservable.</p>

<p>TL;DR, Rx is REALLY HARD. You have seemingly simple primitives of
observers and observables (saying nothing of that
almost-namespace-collision), but the way scalar things become vectors,
merged back into scalars, and not just at the events level but in the
primitives themselves, and how things are hot and cold. Jesus Christ.</p>

<h2>iOS Permissions</h2>

<ul>
<li>iOS7

<ul>
<li>no camera permissions</li>
<li>location permissions, but doesn&#8217;t distinguish b/w foreground/background</li>
<li>once denied, permissions dialog won&#8217;t show up</li>
</ul>
</li>
<li>iOS8

<ul>
<li>permissions for audio and video, separately</li>
<li>location

<ul>
<li>global location shutdown in addition to</li>
<li>app-specific:

<ul>
<li>authorized for &#8220;When in use&#8221;</li>
<li>authorized for background</li>
<li>denied</li>
</ul>
</li>
<li>if you change permissions

<ul>
<li>app will NOT restart</li>
<li>if you&#8217;re disabling geolocation, when you come back
into the app, you won&#8217;t get an error code about lack</li>
</ul>
</li>
</ul>
</li>
<li>for all permissions:

<ul>
<li>once denied, permissions dialog won&#8217;t show up

<ul>
<li>You can open Settings via settings url w some instructions
telling user to reset</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-03-25T11:15:00-04:00" pubdate data-updated="true">Mar 25<span>th</span>, 2015</time></div>
	


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/03/19/today-i-learn-top/">
		
			Today I Learn Top</a>
	</h2>
	<div class="entry-content">
		<h2>top</h2>

<p>PR is priority, which is dynamic; a running process will get less and
less priority over time. NI is nice value; the fixed value that adds to
priority.</p>

<h2>Ruby mem</h2>

<p>http://samsaffron.com/archive/2014/04/08/ruby-2-1-garbage-collection-ready-for-production</p>

<ul>
<li>Ruby tracks malloc&#8217;s</li>
<li>classically, every <code>RUBY_GC_MALLOC_LIMIT</code> bytes,</li>
</ul>


<p>Heaps</p>

<ul>
<li>Ruby maintains heaps of RVALUES.</li>
<li>RVALUES are c union structs, variable size depending on x64, x32, etc,
that are low level representations of ruby objects</li>
<li>require &#8216;objspace&#8217; lets you access ObjectSpace, which exposes the
linked list of free Ruby objects.</li>
<li>RVALUES are collected and reused; mallocs only happen when you expand
beyong the RVALUE list.</li>
</ul>


<p>GC minor/major sweeps:</p>

<p>Flow is this:</p>

<ul>
<li><p><code>Object.allocate</code> (in the course of calling <code>new</code>)</p>

<ul>
<li>gimme a free RVALUE

<ul>
<li>if no free RVALUES, do a sweep</li>
<li>figure out along the way if it needs to be a major sweep</li>
<li>blah blah blah i don&#8217;t want to keep doing this</li>
</ul>
</li>
</ul>
</li>
<li><p>major sweep: run when malloc limit is hit (used to be 8MB, now it&#8217;s a
moving target)</p>

<ul>
<li>so you can malloc a bunch of times but once you hit malloc limit
it&#8217;s time for a major GC</li>
</ul>
</li>
<li>minor: run whenever heap slots run out

<ul>
<li>presumably, if this doesn&#8217;t free up enough mem, a malloc needs to
happen? or maybe a malloc always happens, and the minor sweep frees
up things for a future allocation attempts? either seem fine.</li>
</ul>
</li>
</ul>


<p>http://samsaffron.com/archive/2013/11/22/demystifying-the-ruby-gc</p>


		
		<a href="/blog/2015/03/19/today-i-learn-top/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-03-19T09:18:00-04:00" pubdate data-updated="true">Mar 19<span>th</span>, 2015</time></div>
	


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/02/21/post-with-the-most/">
		
			Post With the Most</a>
	</h2>
	<div class="entry-content">
		<h2>DI, Clojure Components</h2>

<p>https://www.youtube.com/watch?v=13cmHf_kt-Q</p>

<p>A component is an object (just like in OOP) that encapsulates some state
but really just tries to focus on behavior rather than the manipulation
of that internal state.</p>

<p>Types of Components:</p>

<ul>
<li><p>State Wrapper</p>

<ul>
<li>e.g. wrap a stateful connection to a database</li>
<li>e.g. open expensive connection object on create, kill on destroy

<ul>
<li><code>(defrecord DB [host conn])</code>

<ul>
<li>host and conn are meant to be private fields, but privacy
isn&#8217;t actually enforcible in clojure</li>
</ul>
</li>
<li>Public API

<ul>
<li><code>(defn query [db &amp; ...] (.doStatement (:conn db)))</code></li>
<li>these functions <em>do</em> access the conn and host fields; they&#8217;re
the &#8220;public methods&#8221;</li>
</ul>
</li>
<li>Constructor

<ul>
<li>You don&#8217;t have to just use (and maybe shouldn&#8217;t use?) the
default defrecord constructor (e.g. ->DB)</li>
<li>Instead you should expose more convenient constructors that
are themselves side-effect less but return the record.</li>
<li>e.g. <code>(defn db [host] (map-&gt;DB {:host host}))</code></li>
<li>NOTE: <code>map-&gt;RECORDNAME</code> is something declared for you by
the <code>defrecord</code> macro, specifically <code>(declare ~(symbol (str 'map-&gt; gname))</code></li>
<li>Again, no side effects&#8230; a constructor just produces an object,
but that object still needs to be kicked into gear in some way,
let&#8217;s say, via:</li>
</ul>
</li>
<li>Lifeycle Protocol

<ul>
<li>Side effects!</li>
</ul>
</li>
</ul>


<p>(defrecord DB [host conn]
  component/Lifecycle
  (start [this]</p>

<pre><code>(assoc this   ;; returns new thing!!! don't just sideeffect the obj
  :conn (Driver/connect host)))
</code></pre>

  (stop [this]

<pre><code>(.stop conn)
this)
</code></pre></li>
</ul>
</li>
<li><p>Service Wrapper</p>

<ul>
<li>a service like Email is initialized with, say, host and api-key,
but after that point, everyone just needs to pass args like
address and body to use it; that state is encapsulated.</li>
</ul>
</li>
<li><p>Domain Model</p>

<ul>
<li>some subset of functionality and represent as a component</li>
<li>as opposed to OOP where you&#8217;d have a Customer obj with both state
for a specific customer as well as methods to control behavior and
manipulate state, a <code>Customers</code> domain model is an aggregate of
behavioral operations.</li>
<li><p>behavioral dependencies are encapsulated together; a Customers
object depends on the db state wrapper and email service</p>

<p>(defrecord Customers [db email])</p>

<p>;; public api:
(defn notify [customers name message]
  (let [{:keys [db email]} customers</p>

<pre><code>    address (query db ... name)]
(send email address message)))
</code></pre></li>
</ul>
</li>
<li><p>Domain Model (cont.)</p>

<ul>
<li>fetches db and email dependencies from customers record&#8230;</li>
<li>&#8230; queries address from db</li>
<li>&#8230; and uses the email service to send it to the customer</li>
</ul>
</li>
<li><p>Constructing components</p>

<ul>
<li>make a <code>defn</code>, tell the name of the dependences with :keywords.</li>
</ul>
</li>
<li>Associative injection

<ul>
<li>a system (container in Ember) is just a map</li>
<li>if you want to stub dependencies, just assoc those stubs

<ul>
<li>weakness: if you base these test systems off the live one,
if you add another component to the live one, you have to
remember to stub it out (hence isolated containers)</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>Sample RxJsbin w testing</h2>

<p>http://jsbin.com/colora/31/edit</p>

<p>Good lord do they need help w docs.</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-02-21T16:33:00-05:00" pubdate data-updated="true">Feb 21<span>st</span>, 2015</time></div>
	


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/02/17/omg-calfornia/">
		
			OMG I&#8217;m in California</a>
	</h2>
	<div class="entry-content">
		<h2>Definitive Ubuntu folder hierarchy</h2>

<p>https://help.ubuntu.com/community/LinuxFilesystemTreeOverview</p>

<pre><code>/bin is a place for most commonly used terminal commands, like ls, mount, rm, etc.

/boot contains files needed to start up the system, including the Linux kernel, a RAM disk image and bootloader configuration files.

/dev contains all device files, which are not regular files but instead refer to various hardware devices on the system, including hard drives.

/etc contains system-global configuration files, which affect the system's behavior for all users.

/home home sweet home, this is the place for users' home directories.

/lib contains very important dynamic libraries and kernel modules

/media is intended as a mount point for external devices, such as hard drives or removable media (floppies, CDs, DVDs).

/mnt is also a place for mount points, but dedicated specifically to "temporarily mounted" devices, such as network filesystems.

/opt can be used to store addition software for your system, which is not handled by the package manager.

/proc is a virtual filesystem that provides a mechanism for kernel to send information to processes.

/root is the superuser's home directory, not in /home/ to allow for booting the system even if /home/ is not available.

/sbin contains important administrative commands that should generally only be employed by the superuser.

/srv can contain data directories of services such as HTTP (/srv/www/) or FTP.

/sys is a virtual filesystem that can be accessed to set or obtain information about the kernel's view of the system.

/tmp is a place for temporary files used by applications.

/usr contains the majority of user utilities and applications, and partly replicates the root directory structure, containing for instance, among others, /usr/bin/ and /usr/lib.

/var is dedicated variable data that potentially changes rapidly; a notable directory it contains is /var/log where system log files are kept.
</code></pre>

<h2>init.d vs init</h2>

<p><code>init.d</code> is old-school SystemV style, wherein you have executable
scripts in <code>/etc/init.d</code> folder which have case statements matching
<code>reload</code>, <code>start</code>, etc, and doing some behavior based on that.</p>

<p><code>/etc/init</code> houses the newer Upstart format largely adopted by Ubuntu,
and within that you have a bunch of <code>.conf</code> files for managing daemons.</p>

<p>init.d / SystemV:</p>

<pre><code>/etc/init.d/nginx restart
</code></pre>

<p>upstart</p>

<pre><code>restart nginx 
# looks up /etc/init/nginx.conf
</code></pre>

<h2>Apple Store Wonkery</h2>

<p>Failed to upload the app, many times, provisioning profile and
certificate shit due to know laptop. Final error within Application
Loader was due to ITMS-4088 error, and was solved when 1) built
everything with fresh certificates / prov profs under machty and 2)
deployed via the other email account which shall not be publicly named
because security.</p>

<h2>File Dialog slowness on 2011 MBP Yosemite</h2>

<p>Just upgraded my 2011 MBP (w SSD drive) to Yosemite and notice a bug
that every time a file dialog closes, regardless of the app, and
regardless of whether a file was chosen or the user cancels, there is a
~15s hanging spinner until it unfreezes. This happens:</p>

<ul>
<li>if the view mode is anything other than Icon mode (e.g. for any list view), AND</li>
<li>there are audio/video files in the folder (e.g. mp3, aiff, mov)</li>
</ul>


<p>If there&#8217;s text only files, or even pdfs or dmgs or other things with
icons, it&#8217;s fine, but one audio/visual</p>


		
		<a href="/blog/2015/02/17/omg-calfornia/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-02-17T05:45:00-05:00" pubdate data-updated="true">Feb 17<span>th</span>, 2015</time></div>
	


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/02/04/i-need-ur-luv/">
		
			I Need Ur Luv</a>
	</h2>
	<div class="entry-content">
		<h2>flatMapObserver</h2>

<p>Whereas flatMap merges the elements of the observable returned from the
mapping fn, flatMapObserver subscribes to each event of the incoming
observable via a similar API to observers, but the return of each fn is
an observable that gets merged/flatMapped.</p>

<p>https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/flatmapobserver.md</p>

<p>NOTE: the observable returned from the onComplete handler does not
cause the generated stream to end; it&#8217;ll be merged with any (possibly
delayed) observables returned from onNext handler.</p>

<h2>State</h2>

<p>State a la Clojure/immutability separates value from
identity, value is a consistent concept over time, and once two values
are equal, they&#8217;re equal forever, because nothing is mutable.</p>

<p>So, what about app state where event handlers are set up? Say you&#8217;ve
done the functional/React-y thing and you have some leaf component that
fires an event into the ethos at some point in time, and you&#8217;ve fluxed
it into some event handler that <code>setState</code>s at the root level. This
event could happen after 10 seconds, 1000 seconds, or possibly
immediately. But if it&#8217;s immediately, is this fundamentally different
from a situation where things are <em>not</em> data down actions up? How is
this different from a two way binding with async settling?</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-02-04T05:45:00-05:00" pubdate data-updated="true">Feb 4<span>th</span>, 2015</time></div>
	


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/01/26/watoozy/">
		
			Watoozy</a>
	</h2>
	<div class="entry-content">
		<h2>DAS</h2>

<p>&#8220;how and why to avoid nil&#8221;</p>

<p>I&#8217;d watched this before, but the last approach is most interesting:</p>

<ul>
<li>embrace immutability</li>
<li>embrace domain objects whose non-nullable properties are part of
their identity</li>
</ul>


<p>Other thoughts:</p>

<p>Block-less <code>it</code> rspec specs are considered pending; useful for writing
out a bunch of specifications at once and implementing them later.</p>

<p>&#8220;pushing complexity down&#8221;</p>

<p>When you&#8217;re writing a test whose behavior depends on dependencies (e.g.
MonthlyBilling class pushes the &#8220;who-to-charge&#8221; logic into the User
classes&#8217;s <code>charge</code> method), you&#8217;re writing a &#8220;systems test&#8221; /
integration test.</p>

<h2>Ebryn machtizzle</h2>

<p>Talking about the sideways problem</p>

<p>https://hackpad.com/Ebryn-Machty-Router-discussion-iRBXvKmKj5v</p>


		
		<a href="/blog/2015/01/26/watoozy/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-01-26T15:55:00-05:00" pubdate data-updated="true">Jan 26<span>th</span>, 2015</time></div>
	


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/01/13/reekris/">
		
			Reekris</a>
	</h2>
	<div class="entry-content">
		<h2>More on Rx state machines</h2>

<p>From https://github.com/logicalguess/rx-state-machine</p>

<pre><code>// Pattern:
// 1. start off with initial door state, 
// 2. scan the UI event stream with a initial door state and a
//    transforming function. The transforming function is the thing
//    that runs the UI event on the current state, and returns the next state.
//    In this case the transforming fn is `transition`.
events.scan(door, transition).map(doorStatus)
    .subscribe(function (value) {
        view.render(value);
    });
</code></pre>

<p>So what I want to do is expose an API where you can group related events
into states, possibly share events between states, get an actions stream,
and&#8230; somehow transition elsewhere after that?</p>

<pre><code>var state = {
  submitForm: function() {
    // this is just a normal callback handler, just like actions api
  },

  // but maybe if you decorate your handler in some way...
  $submitForm: function(stream) {
    // ... you get a stream of actions instead
    // What should this API look like? How to export another stream
    // or property? 
    // Goals:
    // - make it easy/possible to
    //   - derive flag/state from action progress
    //   - 
  }
};

&lt;form &gt;
  &lt;SubmitButton action='submitForm'&gt;
&lt;/form&gt;
</code></pre>

<h2>Harness</h2>

<p>I don&#8217;t think I&#8217;ve ever grokked the word &#8220;harness&#8221; in a computer science
context.</p>

<blockquote><p>a set of straps and fittings by which a horse or other draft animal is fastened to a cart, plow, etc., and is controlled by its driver.</p></blockquote>

<p>So, a horse harness, wrapped around a horse to control it. Or a
parachute harness that wraps around a person to levitate them. Or a
child-restraining harness.</p>

<pre><code>so in this case, it takes a compiled ember CLI app that can normally run by itself, adds some bootstrap code, and runs it in a different environment

wrapper is maybe a synonym

but with slightly different connotations

I think of a harness as "holding the software in place" so you can make modifications to it, then run it

whereas wrapper implies you're trying to hide the underlying software
</code></pre>

<p>So put the otherwise self-contained / self-sufficient software in a
harness so you can run a bunch of tests on it, run it in a different
environment.</p>


		
		<a href="/blog/2015/01/13/reekris/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-01-13T17:06:00-05:00" pubdate data-updated="true">Jan 13<span>th</span>, 2015</time></div>
	


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/01/07/a-life-of-possibilities/">
		
			A Life of Possibilities</a>
	</h2>
	<div class="entry-content">
		<h2>More actions shit</h2>

<p>Scenario: mobile app, I have a back button, I don&#8217;t want it to cause
another transition if the app is in mid-transition.</p>

<p>Mid-transition means:</p>

<ul>
<li>data has already started loading for a target route, or</li>
<li>some animation is underway, e.g. liquid fire</li>
</ul>


<p>Present day Ember:</p>

<ul>
<li><code>willTransition</code> hook to check some &#8220;isTransitioning&#8221; state (which you
have to remember to properly set and unset (though ember could/should
probably provide this for you))</li>
<li>some other router reopen hook, override transitionTo behavior. Pretty
crappy.</li>
</ul>


<p>React w react-router:</p>

<pre><code>Router.run(routes, function (Handler) {
  // custom data-loading logic, construct your own chain of promises
  // ...
  // maybe use flatMapLatest so that you're only responding to the
  // most recent transition, and then eventually:
  // React.render(&lt;Handler/&gt;, document.body);

  // this could be modeled by a stream 
});
</code></pre>

<p>Hmm so I want to be able to push values into a stream (let&#8217;s call it raw
stream), but have it only come out the other side if some other&#8230;
stream? predicate? allows it.</p>

<h2>Rx/Bacon Diagrams</h2>

<ul>
<li>Bacon: <code>flatMapConcat</code> (or <code>flatMapWithConcurrencyLimit(1)</code>)</li>
<li>Rx: <code>concatAll</code></li>
</ul>


<p>Flatten, preserve order of previously started streams (buffers later streams)</p>

<pre><code>...{1}
......{2........3}
.........{}
............{4}
{...1..2........3.4}
</code></pre>

<ul>
<li>Bacon: <code>flatMap</code> (or <code>flatMapWithConcurrencyLimit(infinity)</code>)</li>
<li>Rx: <code>mergeAll</code></li>
</ul>


<p>Flatten, don&#8217;t preserve order (no buffering). (limiting concurrency
means buffering).</p>

<pre><code>...{1}
......{2........3}
.........{}
............{4}

produces
{...1..2.....4..3}
</code></pre>

<ul>
<li>Bacon: <code>flatMapLatest</code></li>
<li>Rx: <code>switchLatest</code></li>
</ul>


<p>Flatten, unsubscribe from previous streams, RIGHT when the new stream
begins, not on its first value!</p>

<pre><code>...{1}
......{2........3}
............{4}

produces
{...1..2.....4}
</code></pre>

<p>and</p>

<pre><code>...{1}
......{2........3}
............{.........4}

produces
{...1..2.....4}
</code></pre>

<h2>CircleCI uses ClojureScript/Om</h2>

<p>http://blog.circleci.com/local-state-global-concerns/</p>

<h2>MRR</h2>

<p>Monthly recurring revenue: a way to calculate monthly revenue based off
of multiple dissimilar subscription terms.</p>

<h2>Observable of 1 is a promise</h2>

<p>http://www.infoq.com/presentations/async-programming-netflix</p>

<p>Promises can&#8217;t be cancelled.</p>

<ul>
<li>Work is already being done (in flight)</li>
<li>No way to stop it</li>
</ul>


<p>Observables are lazy. You can build a giant nested logical chunk of
observable but nothing happens until, say, a <code>forEach</code> subscribes to the
result of an observable that all the internal logic kicks into place.
Not true for promises (unless someone implements a lazy thennable).</p>

<p>TODO: hot vs cold observables distinction? does this exist in bacon?</p>

<p>This is how the <code>retry</code> operator works&#8230; in the same way you can call
<code>forEach</code> N times on an observable and kick start all the internal
logic/event handlers, retry will internally do this until it gets a
non-error response.</p>

<p>This is unless promises, which have the <code>.then</code> operator:</p>

<ul>
<li>Regardless of whether you call <code>.then</code>, the promise logic has already started</li>
<li>Calling <code>.then</code> at the same time just subscribes to the single,
already running promise, and <code>.then</code> on an already resolved promise
just returns that.</li>
</ul>



		
		<a href="/blog/2015/01/07/a-life-of-possibilities/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-01-07T14:07:00-05:00" pubdate data-updated="true">Jan 7<span>th</span>, 2015</time></div>
	


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/01/04/everything-and-nothin/">
		
			Everything and Nothin</a>
	</h2>
	<div class="entry-content">
		<h2>Indemnity</h2>

<p>http://en.wikipedia.org/wiki/Indemnity</p>

<p>Where indemnitor A pays B a sum of money to cover losses suffered by B
(regardless of whether A caused/was responsible for the loss).
Car insurance is an example. Life insurance is not, since the payout is
not based on any &#8220;valuation&#8221; of the life..</p>

<p>HMOs basically get involved with health care options to try and secure
efficient/cheap means of good healthcare, rather than traditional
indemnity insurance, which would, uhh, just pay out after the fact and
not get involved beforehand?</p>

<h2>HMO act of 1973</h2>

<p>http://en.wikipedia.org/wiki/Health_Maintenance_Organization_Act_of_1973</p>

<ul>
<li>signed by nixon</li>
<li>intended to curb medical inflation</li>
<li>provided grants/loans to start an HMO, removed certain state
restrictions for federally qualified HMOs</li>
<li>required employers w 25+ employees to offer federally certified HMO
options <em>if</em> the employer was already offering traditional insurance</li>
<li>did NOT require employers to offer health insurance</li>
<li>established/solidied the term HMO</li>
</ul>


<h2>Humble Bundle</h2>

<p>http://en.wikipedia.org/wiki/Humble_Bundle</p>

<p>Series of collections (bundles) of digital thingers, often games,
distributed via pay-what-you-want. The more you pay, the more that&#8217;s
opened up. Configurable, but most pay goes to developers, some to
charity, some to Humble.</p>

<h2>What is JLD in Empire Blue?</h2>

<p>JLD is a network code representing the Pathway Enhanced network of
doctors, pharmaceuticals, etc.</p>

<p>The ID number on the card is network + member ID.</p>

<p>1-866-755-2680 Tech support for the website.</p>

<p>Even though they don&#8217;t put it on the card this year, my co-pay is $30,
which I always pay. After I blast through deductible, co-insurance kicks
in. But preventative visits to PCP are freeeeee. But if it&#8217;s not
preventative, the doctor will submit it to insurance as a different
code, which I have to pay for out of deductible. Otherwise shit is
freeeee.</p>

<p>What&#8217;s the difference between Empire and Anthem?</p>

<p>There&#8217;s Empire BlueCross BlueShield and Anthem BlueCross BlueShield?</p>

<p>OK OK OK BlueCross BlueShield is a federation (bigass organization where
smaller groups have decent autonomy). Was originally Blue Cross in 1929,
and a separate Blue Shield in 1948, and they merged in 1982.</p>

<p>Anthem is their only publicly traded company, and within New York they
operate as &#8220;Empire&#8221; BlueCross. Jesus Christ these companies are too
fucking huge.</p>

<ul>
<li>Blue Cross Blue Shield

<ul>
<li>Anthem (publicly traded)

<ul>
<li>Empire Blue Cross Blue Shield (operates out of New York)</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>Difference b/w renter&#8217;s and home owner&#8217;s insurance</h2>

<p>http://coverhound.com/insurance-learning-center/homeowners-vs-renters-insurance-a-big-difference</p>

<ul>
<li>Renters

<ul>
<li>You insure belongings, not the building</li>
</ul>
</li>
<li>Homeowners

<ul>
<li>You insure the building, and the belongings

<ul>
<li>Hence it&#8217;s way more expensive</li>
</ul>
</li>
<li>Insurance is often mandatory if you have a mortgage, but probably
not legally required if you straight up own the whole thing.</li>
</ul>
</li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-01-04T22:26:00-05:00" pubdate data-updated="true">Jan 4<span>th</span>, 2015</time></div>
	


	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/01/02/omnifocus-et-al/">
		
			OmniFocus Et Al</a>
	</h2>
	<div class="entry-content">
		<h2>OmniFocus</h2>

<ul>
<li>Quick action add: ctrl+option+space</li>
<li>Send to inbox: Ctrl+F6

<ul>
<li>Note this is a Service that some reason not all apps implement?
But it works in Chrome so I think we&#8217;re good</li>
</ul>
</li>
<li>Once you assign an inbox item to a project, it&#8217;s removed from the project</li>
<li>Someday maybe:

<ul>
<li>Put in single action project, mark project as on hold.</li>
</ul>
</li>
<li>So projects can have an On Hold status&#8230; but there&#8217;s also a waiting context?

<ul>
<li>Ah, both projects and contexts can choose what status they are&#8230;
from the same list of possible statuses.</li>
</ul>
</li>
<li>How does the repeat work? &#8220;1 week&#8221;? Why does it say multiple values?

<ul>
<li>Ah I should probably do this one at a time. The way it works is once
you complete, it&#8217;ll immediately schedule another one.</li>
</ul>
</li>
</ul>


<p>OmniFocus is implements GDT: <a href="http://gettingthingsdone.com/">Getting Things Done</a></p>

<h2>Elephants in Trees</h2>

<p>Why do you never see elephants hiding in trees?</p>

<p>Because they&#8217;re very good at it.</p>


		
		<a href="/blog/2015/01/02/omnifocus-et-al/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-01-02T16:27:00-05:00" pubdate data-updated="true">Jan 2<span>nd</span>, 2015</time></div>
	


	
</div></article>

<nav id="pagenavi">
    
        <a href="/" class="prev">Prev</a>
    
    
        <a href="/blog/page/3/" class="next">Next</a>
    
    <div class="center"><a href="/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2015

    Alex Matchneer

<br>
Powered by Octopress.
</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'usefuldude';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-49928757-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>

