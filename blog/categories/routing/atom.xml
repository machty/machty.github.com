<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: routing | machty's thoughtz]]></title>
  <link href="http://machty.github.com/blog/categories/routing/atom.xml" rel="self"/>
  <link href="http://machty.github.com/"/>
  <updated>2014-09-30T16:55:34-04:00</updated>
  <id>http://machty.github.com/</id>
  <author>
    <name><![CDATA[Alex Matchneer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[DRY and Tie Your Ember Routes]]></title>
    <link href="http://machty.github.com/blog/2012/09/28/dry-your-ember-routes/"/>
    <updated>2012-09-28T13:54:00-04:00</updated>
    <id>http://machty.github.com/blog/2012/09/28/dry-your-ember-routes</id>
    <content type="html"><![CDATA[<h4>UPDATE 10/1/12: see bottom the post for avoiding infinite loop issues</h4>

<h4>UPDATE 1/6/12: this post is deprecated since the new <a href="http://emberjs.com/guides/routing/defining-your-routes/">Ember Router v2 API</a> came out.</h4>

<p>A common complaint about Ember.js routing is that seems to force you to
create pairs of extremely light-weight, useless Views and Controllers
for each new route you create. Another is that it's not particular
obvious how data ought to be shared between routes/controllers. Here's
one way to cut down on the seeming boilerplate while linking your data.</p>

<!--more-->


<p>Consider the following example router
that describes an application that allows you to create new Campaigns,
but the forms for filling out all the information about a Campaign are
split between multiple pages.</p>

<p>{% codeblock app_router.js.coffee lang:coffeescript %}
App.Router = Em.Router.extend
  root: Em.Route.extend</p>

<pre><code># ... index route, redirect-to's, etc.

new_campaign: Em.Route.extend
  route: '/new_campaign'
  connectOutlets: (router) -&gt;
    # 1. Instantiate a NewCampaignController and NewCampaignView,
    # and inject the latter into applicationController's outlet.
    # also create the empty Campaign object that will be 
    # shared between the multiple pages of forms and pass it in
    # as the context object to the controller.
    router.get('applicationController').connectOutlet('newCampaign', App.Campaign.createRecord())

  basic_info: Em.Route.extend
    route: '/basic_info'
    connectOutlets: (router) -&gt;
      # 2. Create BasicInfoController and BasicInfoView, inject
      # into the NewCampaignView outlet.
      router.get('newCampaignController').connectOutlet('basicInfo')

  more_info: Em.Route.extend
    route: '/more_info'
    connectOutlets: (router) -&gt;
      router.get('newCampaignController').connectOutlet('moreInfo')

  #... a third page
</code></pre>

<p>{% endcodeblock %}</p>

<p>There's two main problems with the code above:</p>

<ol>
<li>The <code>basic_info</code> and <code>more_info</code> child state controllers haven't yet
been connected to the Campaign object created for the parent
<code>new_campaign</code> state.</li>
<li>Already, you've got to implement a bunch of nearly empty Views and
Controllers, namely:</li>
</ol>


<p>{% codeblock app_router.js.coffee lang:coffeescript %}
App.NewCampaignView = Em.View.extend
  templateName: "new_campaign"
App.NewCampaignController = Em.Controller.extend()</p>

<p>App.BasicInfoView = Em.View.extend
  templateName: "basic_info"
App.BasicInfoController = Em.Controller.extend()</p>

<p>App.MoreInfoView = Em.View.extend
  templateName: "more_info"
App.MoreInfoController = Em.Controller.extend()
{% endcodeblock %}</p>

<p>First off, if you're a 1-to-1 class-to-file kind of person, your
codebase, app namespace, and editor tab space will bloat with nearly
empty View and Controller definitions. Sucks.</p>

<p>Fortunately, if the <code>connectOutlet</code> function comes in all sorts of
flavors, one where you you can pass in an options hash rather than
a string to specify exactly which Views / Controllers to create and what
your context option should be. Let us kill off the <code>BasicInfo</code>- and <code>MoreInfo</code>-
Controllers via the following:</p>

<p>{% codeblock lang:coffeescript %}</p>

<h1>App.Router = ...</h1>

<pre><code>  basic_info: Em.Route.extend
    connectOutlets: (router) -&gt;
      router.get('newCampaignController').connectOutlet
        viewClass: App.BasicInfoView

  more_info: Em.Route.extend
    connectOutlets: (router) -&gt;
      router.get('newCampaignController').connectOutlet
        viewClass: App.MoreInfoView
</code></pre>

<p>{% endcodeblock %}</p>

<p>Turns out we've actually solved both problems: we no longer need
<code>BasicInfoController</code> or <code>MoreInfoController</code>, and we've actually
tied the templates for <code>BasicInfoView</code> and <code>MoreInfoView</code> correctly
to the Campaign object in NewCampaignController, and how exactly does
that work?</p>

<h3>Default Context Resolution: parentView</h3>

<p>Well, ever since
<a href="https://gist.github.com/2494968">Ember changed the way it resolves contexts</a>,
the context of a template is determined, by default, by looking up the
<code>controller</code> property of the View and using that if it exists, otherwise
it checks up the chain of <code>parentView</code>s to see if any of them have
defined a <code>controller</code> property to use as the context. <code>BasicInfoView</code>
and <code>MoreInfoView</code> don't have controllers set (since we're using the
<code>viewClass</code>-only form of <code>connectOutlet</code>), so their contexts resolve to
their <code>parentView</code>'s <code>controller</code>, namely <code>NewCampaignController</code>.
Therefore, the Handlebars templates for <code>BasicInfoView</code> and
<code>MoreInfoView</code> now use the <code>Campaign</code> object as their context.</p>

<h3>Can we do better?</h3>

<p>You might be itching to get rid of <code>BasicInfo-</code> and <code>MoreInfoView</code> as
well, since all they do is specify their <code>templateName</code>. You could do
this, if you wanted, by doing
<code>viewClass: Em.View.extend(templateName: "basic_info")</code>, but that seems
like overkill to me. Plus, you'd lose the benefits of being able to,
say, automatically focus a text field via the View's <code>didInsertElement</code>
hook.</p>

<h3>Where can I learn more?</h3>

<p>Documentation on Ember routing is still pretty meager, so I'd definitely
encourage you to really dig into the Ember source, particularly the test
cases that deal with these kinds of issues. For example, tucked right in
the middle of <code>controller_test.js</code> is</p>

<p>{% codeblock app_router.js.coffee lang:javascript %}
test("if the controller is explicitly set to null while connecting an outlet, the instantiated view will inherit its controller from its parent view", function() { ...
{% endcodeblock %}</p>

<p>Which isn't exactly what's happening regarding context resolution, but still clued me into this
approach.</p>

<h3>Update: Infinite Loop Gotcha</h3>

<p>I've been refactoring like a madman since discovering this and in some
cases I was getting stack overflows that were hard to trace down, but I
found the cause: if the <code>viewClass</code> you specify has an unnamed
<code>outlet</code> in its template, you'll get an infinite loop. I'm 90% sure
the reason why is that when you use the <code>viewClass</code>-only form of
connectOutlet, the default outlet name resolves to <code>view</code> (the default)
and steps on the namespace toes of the parent view outlet that 1) had
the same name (view) and was 2) (more importantly) tied to the same
single controller. So, there's namespace collisions. You can avoid this
by either getting rid of the leaf view's <code>outlet</code> (which might be
the case if you've been unquestioningly throwing outlets into templates
that don't actually inject child views... we're probably all guilty of
this at some point in our struggles with the router), or, if you
actually need the outlet, just give it a sensible name that won't
collide with any other outlet attached to the shared controller. Then
when you want to inject a view into <em>that</em> outlet, you can do:</p>

<p>{% codeblock app_router.js.coffee lang:coffeescript %}</p>

<p>  basic_info: Em.Route.extend</p>

<pre><code>route: '/basic_info'
connectOutlets: (router) -&gt;
  router.get('newCampaignController').connectOutlet
    viewClass: App.BasicInfoView

index: Em.Route.extend
  route: '/'

captcha: Em.Route.extend
  route: '/captcha'
  connectOutlets: (router) -&gt;
    # Assume theres an outlet named captcha in the basic_info template.
    router.get('newCampaignController').connectOutlet
      viewClass: App.CaptchaView
      outletName: 'captcha'
</code></pre>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
