<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: batterypop | machty's thoughtz]]></title>
  <link href="http://machty.github.com/blog/categories/batterypop/atom.xml" rel="self"/>
  <link href="http://machty.github.com/"/>
  <updated>2014-09-30T16:55:34-04:00</updated>
  <id>http://machty.github.com/</id>
  <author>
    <name><![CDATA[Alex Matchneer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[batteryPOP is Live]]></title>
    <link href="http://machty.github.com/blog/2012/10/12/batterypop-is-live/"/>
    <updated>2012-10-12T10:50:00-04:00</updated>
    <id>http://machty.github.com/blog/2012/10/12/batterypop-is-live</id>
    <content type="html"><![CDATA[<p>You can check out the latest <a href="http://www.usefulrobot.io">Useful Robot</a>
project at <a href="http://www.batterypop.com">batteryPOP.com</a>.</p>

<p>batteryPOP is a children's website featuring a bubbly, animated,
tree-based menu that drives kids to the videos they want to watch and
articles they want to read. It was written in
<a href="http://www.emberjs.com">Ember.js</a>/Rails and had to look good on the
iPad, so we couldn't use any Flash, though the effect is largely the
same.</p>

<!-- more -->


<h2>Ember.js Meetup Presentation</h2>

<p>Here's the slides from my lightning talk on Architecting batteryPOP from
the last <a href="http://www.meetup.com/EmberJS-NYC/">NYC Ember Meetup</a>.</p>

<script async class="speakerdeck-embed" data-id="5059e707e4ce5c0002054198" data-ratio="1.4840579710144928" src="http://machty.github.com//speakerdeck.com/assets/embed.js"></script>


<h2>Repositionables</h2>

<p>One of the major focuses of that presentation was on
how to use a <code>Repositionable</code> mixin in conjunction with
position formulas so that views can automatically get notified when
browser dimensions change and automatically animate themselves to the
correct new position and scale. This is what facilitates the nifty
auto-adjust feature on batteryPOP.com when you scale the browser window.
Try it. It's nifty.</p>

<p>It's also what allows the site to 'just work' when
viewed on a variety of different devices; there's no special iPad
version of the site, or device-specific CSS, just a bunch of Views that
know how to scale and position themselves based on browser dimensions
and a suite of reusable position formulas.</p>

<h2>PagedNodeOrchestrator</h2>

<p>Also discussed was what I called the <code>PagedNodeOrchestrator</code>, which
handles the paging and animation of children nodes at a certain level in
the tree-based menu structure. If you go to batteryPOP.com and click
What's Poppin', you're 1 level deep in the tree menu, and there are (at
present) 12 nodes to display which get split into 2 pages of 6. Paging
left and right causes nodes to animate in and out of existence.</p>

<p>Furthermore, there are instances when user actions cause nodes to be
added/removed from the list (adding/removing items from your homepage),
and the menu will need to automagically rebalance and occasionally
collapse 2 pages into one and so on and so on. Due to all of the insane
whack-a-mole corner cases that presented themselves once I started in on
the more dynamic user homepage, the only solution was to write a
<code>PagedNodeOrchestrator</code>, which (similar to and based on
<code>Ember.CollectionView</code>) responds to changes in an underlying array of
models and automatically handles the generation, deletion, and animation
of their associated views as models are added/removed to the underlying
array and the <code>currentPageNumber</code> changes. Once I'd nailed down the code
to handle the basic paging/addition/deletion, all of those corner cases
resolved themselves. You can imagine my fist-pumping, Adderall-fueled
delight at Fourthmeal o'clock.</p>

<h3>Code Excerpt</h3>

<p>Here's all the important bits of the <code>PagedNodeOrchestrator</code> for anyone
who's interested in constructing a similar View-ish structure that
responds to changes in an underlying array. I've left some of the more
Shakespearian commenting intact.</p>

<p>{% codeblock paged_node_orchestrator.js.coffee lang:coffeescript %}
App.PagedNodeOrchestrator = Em.Object.extend</p>

<p>  init: -></p>

<pre><code>@set "nodeViews", []
@_nodeModelsDidChange()
</code></pre>

<p>  # When nodeModels changes, handle observer changes and
  # notify our callback. Note that a change in nodeModels
  # means that someone changed the entire fucking
  # array, and not just a few elements in there.
  # We take this opportunity to let our arrayWillChange
  # observer know what's up.
  _nodeModelsWillChange: Ember.beforeObserver((-></p>

<pre><code>if nodeModels = @get('nodeModels')
  nodeModels.removeArrayObserver @
len = if nodeModels then nodeModels.get("length") else 0
@arrayWillChange(nodeModels, 0, len)
</code></pre>

<p>  ), 'nodeModels')</p>

<p>  _nodeModelsDidChange: Ember.observer(( -></p>

<pre><code>if nodeModels = @get('nodeModels')
  nodeModels.addArrayObserver @

len = if nodeModels then nodeModels.get("length") else 0
@arrayDidChange(nodeModels, 0, null, len)
</code></pre>

<p>  ), 'nodeModels')</p>

<p>  # Ember.sendEvent(this, '@array:before', [this, startIdx, removeAmt, addAmt]);
  arrayWillChange: (___, start, removedCount) -></p>

<pre><code># Basically, I need to cast away and destroy the nodeViews
# associated with the deleted nodeModels in nodeModels. I'll
# shorten the nodeViews array here and then add to it
# in didChange
@destroyNodeViewRange(start, removedCount)

# Now remove those nodeViews from the list.
@get("nodeViews").replace(start, removedCount, 0)
</code></pre>

<p>  arrayDidChange: (nodeModels, start, removed, added) -></p>

<pre><code># Fill in nodeViews with undefined space. 
nodeViews = get(@, 'nodeViews')
nodeViews.replace(start, 0, new Array(added))

modelLen = if nodeModels then nodeModels.get("length") else 0
viewLen  = if nodeViews then nodeViews.get("length") else 0
Ember.assert(fmt("Node arrays out of sync! %@ vs. %@", [modelLen, viewLen]), modelLen == viewLen)
@refreshDisplay()
</code></pre>

<p>  currentPaging: ( -></p>

<pre><code># First, determine the balanced page size.
TARGET_PAGE_SIZE = 6
nodeModels = @get "nodeModels"
len = if nodeModels then nodeModels.length else 0
numPages = Math.ceil(len / TARGET_PAGE_SIZE) || 1
nodesPerPage = Math.ceil(len / numPages)

# Now determine the range of visible node indexes
# given the currentPageIndex. We also have to make sure
# to stay within the bounds in case we lost a bunch of nodes
# and we were on a later page.
currentPageIndex = Math.min(@get("currentPageIndex"), numPages - 1)
visibleStart = currentPageIndex * nodesPerPage
visibleEnd = Math.min(len, visibleStart + nodesPerPage)
currentPageSize = visibleEnd - visibleStart

{
  numPages: numPages
  currentPageIndex: currentPageIndex
  maxNodesPerPage: nodesPerPage
  currentPageSize: currentPageSize

  # Indexes controlling which nodes are currently displayed:
  # [ visibleStart, visibleEnd )
  visibleStart: visibleStart
  visibleEnd: visibleEnd
}
</code></pre>

<p>  ).property("currentPageIndex", "nodeModels.length")</p>

<p>  refreshDisplay: (force = false) -></p>

<pre><code>nodeModels = @get "nodeModels"

# Calculate paging and update properties.
currentPaging = @get "currentPaging"
@set "numPages", currentPaging.numPages
@set "currentPageIndex", currentPaging.currentPageIndex
visibleStart = currentPaging.visibleStart
visibleEnd = currentPaging.visibleEnd
currentPageSize = currentPaging.currentPageSize

# Loop through all models, creating nodeViews in the visible spectrum
# and hiding the ones that aren't supposed to be there.
nodeViews = @get("nodeViews")

for idx in [0...(nodeModels.length)]
  nodeModel = nodeModels[idx]
  nodeView = nodeViews[idx]

  if nodeView
    # NodeView has been created. Should it be here?
    if visibleStart &lt;= idx &lt; visibleEnd
      # Yes, it should. Make sure it's in the right place.
      @presentNodeView(nodeView, (idx - visibleStart) / currentPageSize + overlapOffset)
    else
      # No, it shouldn't be here. Send it in the proper direction
      # if it's actually visible
      continue if nodeView.getPath("displayProperties.opacity") &lt; 0.1
      positionFormula = if idx &lt; visibleStart
        App.PagedOutRightPosition
      else
        App.PagedOutLeftPosition
      nodeView.set "positionFormula", positionFormula
      nodeView.notifyPropertyChange "positionFormula"
  else
    # No nodeview exists in this slot yet. Should we create on?
    if visibleStart &lt;= idx &lt; visibleEnd
      console.log "Index #{idx}: Creating node here"
      # Yes we should.
      nodeView = App.nodeViewFactory(nodeModel)
      nodeViews[idx] = nodeView
      @presentNodeView(nodeView, (idx - visibleStart) / currentPageSize + overlapOffset, true)
</code></pre>

<p>  presentNodeView: (nodeView, orbitRatio, firstDisplay = false) -></p>

<pre><code>nodeView.set "stackController", @
nodeView.set "orbitRatio", orbitRatio
nodeView.set "positionFormula", App.PrePresentPosition if firstDisplay

# TODO: combine into one timer event?
positioner = =&gt;
  #debugger
  nodeView.set "positionFormula", App.OrbitingPosition
  nodeView.notifyPropertyChange "positionFormula"

if firstDisplay
  runLater 1, positioner
else
  positioner()
</code></pre>

<p>  # @param {callback}: function(nodeView, index)
  forEachVisibleNodeView: (callback) -></p>

<pre><code>currentPaging = @get "currentPaging"
nodeViews = @get "nodeViews"

visibleStart = currentPaging.visibleStart

for idx in [visibleStart...(currentPaging.visibleEnd)]
  nodeView = nodeViews[idx]
  newNodeView = callback nodeView, idx - visibleStart
</code></pre>

<p>{% endcodeblock %}</p>

<h3>Monitoring Changes on an Underlying Array</h3>

<p>So, to create any sort of object that responds to changes in an
underlying array (in Ember.js), one must</p>

<ol>
<li>Observe changes to the entire array property (i.e. handle the case
when someone sets <code>content</code> to an entirely different array, rather
than just adding to / removing from the existing array)</li>
<li>Use this observer to call <code>addArrayObserver</code>/<code>removeArrayObserver</code> on the
new/old array so that we can receive notifications on when individual
elements are added/removed from the array.</li>
</ol>


<p>This is the pattern that my <code>PagedNodeOrchestrator</code> follows, which
totally ripped off the pattern from the source for
<code>Ember.CollectionView</code>. Definitely take a look at the <code>CollectionView</code>
source for better commenting and less CoffeeScript and curse words.</p>
]]></content>
  </entry>
  
</feed>
